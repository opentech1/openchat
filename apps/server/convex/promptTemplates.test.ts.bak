/**
 * Comprehensive Tests for Prompt Template Functions
 *
 * Tests all prompt template operations including:
 * - Template creation with validation and sanitization
 * - Template listing with pagination and filtering
 * - Template retrieval by ID and command
 * - Template updates and auto-save
 * - Template deletion (soft delete)
 * - Usage count tracking
 * - Rate limiting
 * - Input sanitization and security
 */

import { convexTest } from "convex-test";
import { expect, test, describe, beforeEach, afterEach } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";
import type { Id } from "./_generated/dataModel";
import path from "path";
import { modules, rateLimiter } from './test-setup';

// Helper to create convex test instance with components registered
function createConvexTest() {
	const t = convexTest(schema, modules);
	rateLimiter.register(t);
	return t;
}


describe("promptTemplates.create", () => {
	let t: ReturnType<typeof convexTest>;

	beforeEach(() => {
		t = createConvexTest();
	});

	afterEach(async () => {
		await t.finish();
	});

	test("should create template with all fields", async () => {

		// Create a user first
		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_1",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Code Review",
			command: "/review",
			template: "Please review this code: $ARGUMENTS",
			description: "Reviews code for best practices",
			category: "coding",
			isDraft: false,
		});

		expect(result.templateId).toBeDefined();

		const template = await t.run(async (ctx) => {
			return await ctx.db.get(result.templateId);
		});

		expect(template).toMatchObject({
			userId,
			name: "Code Review",
			command: "/review",
			template: "Please review this code: $ARGUMENTS",
			description: "Reviews code for best practices",
			category: "coding",
			isDraft: false,
			isPublic: false,
			usageCount: 0,
		});
	});

	test("should create template with minimal fields", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_2",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Simple Template",
			command: "/simple",
			template: "Simple template content",
		});

		expect(result.templateId).toBeDefined();

		const template = await t.run(async (ctx) => {
			return await ctx.db.get(result.templateId);
		});

		expect(template?.description).toBeUndefined();
		expect(template?.category).toBeUndefined();
		expect(template?.isDraft).toBe(false);
	});

	test("should sanitize command by removing leading slash", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_3",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Test",
			command: "/test-command",
			template: "Test",
		});

		const template = await t.run(async (ctx) => {
			return await ctx.db.get(result.templateId);
		});

		expect(template?.command).toBe("/test-command");
	});

	test("should sanitize command to lowercase and alphanumeric", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_4",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Test",
			command: "TEST-Command_123",
			template: "Test",
		});

		const template = await t.run(async (ctx) => {
			return await ctx.db.get(result.templateId);
		});

		expect(template?.command).toBe("/test-command_123");
	});

	test("should reject duplicate command for same user", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_5",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "First Template",
			command: "/duplicate",
			template: "First",
		});

		await expect(
			t.mutation(api.promptTemplates.create, {
				userId,
				name: "Second Template",
				command: "/duplicate",
				template: "Second",
			})
		).rejects.toThrowError(/already exists/);
	});

	test("should allow same command for different users", async () => {

		const { userId: userId1 } = await t.mutation(api.users.ensure, {
			externalId: "user_template_6a",
		});

		const { userId: userId2 } = await t.mutation(api.users.ensure, {
			externalId: "user_template_6b",
		});

		const result1 = await t.mutation(api.promptTemplates.create, {
			userId: userId1,
			name: "Template 1",
			command: "/shared",
			template: "Template 1",
		});

		const result2 = await t.mutation(api.promptTemplates.create, {
			userId: userId2,
			name: "Template 2",
			command: "/shared",
			template: "Template 2",
		});

		expect(result1.templateId).toBeDefined();
		expect(result2.templateId).toBeDefined();
		expect(result1.templateId).not.toBe(result2.templateId);
	});

	test("should enforce rate limit on template creation", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: `user_template_rate_${Math.random().toString(36)}`,
		});

		// Try to create many templates quickly (rate limit is 20/min with 5 burst = 25 total)
		const promises = [];
		for (let i = 0; i < 30; i++) {
			promises.push(
				t.mutation(api.promptTemplates.create, {
					userId,
					name: `Template ${i}`,
					command: `/cmdrate${i}_${Math.random().toString(36).substring(7)}`,
					template: `Template ${i}`,
				})
			);
		}

		await expect(
			Promise.all(promises)
		).rejects.toThrowError(/Too many templates created/);
	});

	test("should reject empty name", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_7",
		});

		await expect(
			t.mutation(api.promptTemplates.create, {
				userId,
				name: "   ",
				command: "/test",
				template: "Test",
			})
		).rejects.toThrowError(/name is required/);
	});

	test("should reject invalid command", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_8",
		});

		await expect(
			t.mutation(api.promptTemplates.create, {
				userId,
				name: "Test",
				command: "!!!",
				template: "Test",
			})
		).rejects.toThrowError(/Valid command is required/);
	});

	test("should reject empty template content", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_9",
		});

		await expect(
			t.mutation(api.promptTemplates.create, {
				userId,
				name: "Test",
				command: "/test",
				template: "   ",
			})
		).rejects.toThrowError(/Template content is required/);
	});

	test("should trim and sanitize input fields", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_template_10",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "  Template Name  ",
			command: "  /test  ",
			template: "  Template content  ",
			description: "  Description  ",
			category: "  coding  ",
		});

		const template = await t.run(async (ctx) => {
			return await ctx.db.get(result.templateId);
		});

		expect(template?.name).toBe("Template Name");
		expect(template?.template).toBe("Template content");
		expect(template?.description).toBe("Description");
		expect(template?.category).toBe("coding");
	});
});

describe("promptTemplates.list", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();

	afterEach(async () => {
		await t.finish();
	});
	});

	test("should list user templates", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_list_1",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template 1",
			command: "/t1",
			template: "Content 1",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template 2",
			command: "/t2",
			template: "Content 2",
		});

		const result = await t.query(api.promptTemplates.list, { userId });

		expect(result.templates).toHaveLength(2);
		expect(result.templates[0].name).toBeDefined();
		expect(result.templates[0].command).toBeDefined();
	});

	test("should not return deleted templates", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_list_2",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "To Delete",
			command: "/delete",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.remove, { templateId, userId });

		const result = await t.query(api.promptTemplates.list, { userId });

		expect(result.templates).toHaveLength(0);
	});

	test("should filter by category", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_list_3",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Coding Template",
			command: "/code",
			template: "Code",
			category: "coding",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Writing Template",
			command: "/write",
			template: "Write",
			category: "writing",
		});

		const result = await t.query(api.promptTemplates.list, {
			userId,
			category: "coding",
		});

		expect(result.templates).toHaveLength(1);
		expect(result.templates[0].name).toBe("Coding Template");
	});

	test("should respect pagination limit", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: `user_list_4_pagination_${Math.random().toString(36)}`,
		});

		// Create only 6 templates to minimize rate limit impact
		for (let i = 0; i < 6; i++) {
			await t.mutation(api.promptTemplates.create, {
				userId,
				name: `Template ${i}`,
				command: `/tpag${i}_${Math.random().toString(36).substring(7)}`,
				template: `Content ${i}`,
			});
		}

		// Request limit of 3 to test pagination
		const result = await t.query(api.promptTemplates.list, {
			userId,
			limit: 3,
		});

		expect(result.templates.length).toBe(3);
		expect(result.nextCursor).toBeDefined(); // Should have more results
	});

	test("should not return templates from other users", async () => {

		const { userId: userId1 } = await t.mutation(api.users.ensure, {
			externalId: "user_list_5a",
		});

		const { userId: userId2 } = await t.mutation(api.users.ensure, {
			externalId: "user_list_5b",
		});

		await t.mutation(api.promptTemplates.create, {
			userId: userId1,
			name: "User 1 Template",
			command: "/u1",
			template: "Content 1",
		});

		await t.mutation(api.promptTemplates.create, {
			userId: userId2,
			name: "User 2 Template",
			command: "/u2",
			template: "Content 2",
		});

		const result = await t.query(api.promptTemplates.list, { userId: userId1 });

		expect(result.templates).toHaveLength(1);
		expect(result.templates[0].name).toBe("User 1 Template");
	});
});

describe("promptTemplates.get", () => {
	let t: ReturnType<typeof convexTest>;

	afterEach(async () => {
		await t.finish();
	});


	beforeEach(() => {
		t = createConvexTest();
	});

	test("should get template by ID", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_get_1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Get Test",
			command: "/get",
			template: "Content",
			description: "Test description",
		});

		const template = await t.query(api.promptTemplates.get, {
			templateId,
			userId,
		});

		expect(template).toBeDefined();
		expect(template?.name).toBe("Get Test");
		expect(template?.description).toBe("Test description");
	});

	test("should return null for other user's template", async () => {

		const { userId: userId1 } = await t.mutation(api.users.ensure, {
			externalId: "user_get_2a",
		});

		const { userId: userId2 } = await t.mutation(api.users.ensure, {
			externalId: "user_get_2b",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId: userId1,
			name: "Private",
			command: "/private",
			template: "Content",
		});

		const template = await t.query(api.promptTemplates.get, {
			templateId,
			userId: userId2,
		});

		expect(template).toBeNull();
	});

	test("should return null for deleted template", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_get_3",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "To Delete",
			command: "/delete",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.remove, { templateId, userId });

		const template = await t.query(api.promptTemplates.get, {
			templateId,
			userId,
		});

		expect(template).toBeNull();
	});
});

	afterEach(async () => {
		await t.finish();
	});

describe("promptTemplates.getByCommand", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should get template by command", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_cmd_1",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Command Test",
			command: "/cmdtest",
			template: "Content",
		});

		const template = await t.query(api.promptTemplates.getByCommand, {
			userId,
			command: "/cmdtest",
		});

		expect(template).toBeDefined();
		expect(template?.name).toBe("Command Test");
	});

	test("should return null for non-existent command", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_cmd_2",
		});

		const template = await t.query(api.promptTemplates.getByCommand, {
			userId,
			command: "/nonexistent",
		});

	afterEach(async () => {
		await t.finish();
	});

		expect(template).toBeNull();
	});
});

describe("promptTemplates.update", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should update template fields", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_update_1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Old Name",
			command: "/old",
			template: "Old Content",
		});

		const result = await t.mutation(api.promptTemplates.update, {
			templateId,
			userId,
			name: "New Name",
			template: "New Content",
		});

		expect(result.ok).toBe(true);

		const template = await t.run(async (ctx) => ctx.db.get(templateId));
		expect(template?.name).toBe("New Name");
		expect(template?.template).toBe("New Content");
	});

	test("should reject duplicate command when updating", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_update_2",
		});

		await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template 1",
			command: "/cmd1",
			template: "Content 1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template 2",
			command: "/cmd2",
			template: "Content 2",
		});

		await expect(
			t.mutation(api.promptTemplates.update, {
				templateId,
				userId,
				command: "/cmd1",
			})
		).rejects.toThrowError(/already exists/);
	});

	test("should allow updating to same command", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_update_3",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template",
			command: "/same",
			template: "Content",
		});

		const result = await t.mutation(api.promptTemplates.update, {
			templateId,
			userId,
			command: "/same",
			name: "Updated Name",
		});

		expect(result.ok).toBe(true);
	});

	test("should enforce rate limit on updates", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: `user_update_rate_${Math.random().toString(36)}`,
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template",
			command: `/rateupdtest${Math.random().toString(36).substring(7)}`,
			template: "Content",
		});

		// Try many updates quickly (rate limit is 30/min with 10 burst = 40 total)
		const promises = [];
		for (let i = 0; i < 50; i++) {
			promises.push(
				t.mutation(api.promptTemplates.update, {
					templateId,
					userId,
					name: `Update ${i}`,
				})
			);
		}

		await expect(
			Promise.all(promises)
		).rejects.toThrowError(/Too many updates/);
	});

	test("should return false for other user's template", async () => {

		const { userId: userId1 } = await t.mutation(api.users.ensure, {
			externalId: "user_update_4a",
		});

		const { userId: userId2 } = await t.mutation(api.users.ensure, {
			externalId: "user_update_4b",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId: userId1,
			name: "Template",
			command: "/test",
			template: "Content",
		});

		const result = await t.mutation(api.promptTemplates.update, {

	afterEach(async () => {
		await t.finish();
	});
			templateId,
			userId: userId2,
			name: "Hacked",
		});

		expect(result.ok).toBe(false);
	});
});

describe("promptTemplates.autoSave", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should auto-save template changes", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_autosave_1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template",
			command: "/auto",
			template: "Content",
		});

		const result = await t.mutation(api.promptTemplates.autoSave, {
			templateId,
			userId,
			name: "Auto Updated",
			template: "Auto Content",
		});

		expect(result.ok).toBe(true);

		const template = await t.run(async (ctx) => ctx.db.get(templateId));
		expect(template?.name).toBe("Auto Updated");
		expect(template?.template).toBe("Auto Content");
	});

	test("should not enforce rate limiting on auto-save", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_autosave_2",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Template",
			command: "/autorate",
			template: "Content",
		});

	afterEach(async () => {
		await t.finish();
	});

		// Should not hit rate limit even with many rapid saves
		for (let i = 0; i < 50; i++) {
			const result = await t.mutation(api.promptTemplates.autoSave, {
				templateId,
				userId,
				name: `Auto ${i}`,
			});
			expect(result.ok).toBe(true);
		}
	});
});

describe("promptTemplates.remove", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should soft delete template", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_remove_1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "To Delete",
			command: "/delete",
			template: "Content",
		});

		const result = await t.mutation(api.promptTemplates.remove, {
			templateId,
			userId,
		});

		expect(result.ok).toBe(true);

		const template = await t.run(async (ctx) => ctx.db.get(templateId));
		expect(template?.deletedAt).toBeDefined();
	});

	test("should enforce rate limit on deletions", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: `user_remove_rate_del_${Math.random().toString(36)}`,
		});

		// Create fewer templates to avoid hitting creation rate limit
		// We need enough to exceed deletion rate limit of 18 (15/min + 3 burst)
		const templateIds = [];
		for (let i = 0; i < 19; i++) {
			const { templateId } = await t.mutation(api.promptTemplates.create, {
				userId,
				name: `Template Del ${i}`,
				command: `/delrate${i}_${Math.random().toString(36).substring(7)}`,
				template: "Content",
			});
			templateIds.push(templateId);
		}

		// Try to delete all quickly in parallel - should hit rate limit at 19th deletion
		const promises = templateIds.map((templateId) =>
			t.mutation(api.promptTemplates.remove, { templateId, userId })
		);

		await expect(
			Promise.all(promises)
		).rejects.toThrowError(/Too many deletions/);
	});

	test("should return false for already deleted template", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_remove_2",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {

	afterEach(async () => {
		await t.finish();
	});
			userId,
			name: "Delete Twice",
			command: "/twice",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.remove, { templateId, userId });

		const result = await t.mutation(api.promptTemplates.remove, {
			templateId,
			userId,
		});

		expect(result.ok).toBe(false);
	});
});

describe("promptTemplates.incrementUsage", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should increment usage count", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_usage_1",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Usage Test",
			command: "/usage",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.incrementUsage, { templateId, userId });

		const template = await t.run(async (ctx) => ctx.db.get(templateId));
		expect(template?.usageCount).toBe(1);
	});

	test("should increment from zero to one", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_usage_2",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Usage Test",
			command: "/usage2",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.incrementUsage, { templateId, userId });
		await t.mutation(api.promptTemplates.incrementUsage, { templateId, userId });
		await t.mutation(api.promptTemplates.incrementUsage, { templateId, userId });

		const template = await t.run(async (ctx) => ctx.db.get(templateId));
		expect(template?.usageCount).toBe(3);
	});

	test("should return false for deleted template", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_usage_3",
		});

		const { templateId } = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Usage Test",
			command: "/usage3",
			template: "Content",
		});

		await t.mutation(api.promptTemplates.remove, { templateId, userId });

		const result = await t.mutation(api.promptTemplates.incrementUsage, {
			templateId,
			userId,
		});

		expect(result.ok).toBe(false);
	});
});

describe("promptTemplates input sanitization", () => {
	let t: ReturnType<typeof convexTest>;



	beforeEach(() => {
		t = createConvexTest();
});

	test("should remove control characters from template", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_sanitize_1",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "Test\x00Name\x01",
			command: "/test",
			template: "Content\x00with\x01control",
		});

		const template = await t.run(async (ctx) => ctx.db.get(result.templateId));
		expect(template?.name).not.toContain("\x00");
		expect(template?.template).not.toContain("\x00");
	});

	test("should truncate very long fields", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_sanitize_2",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "a".repeat(200),
			command: "/test",
			template: "Content",
		});

		const template = await t.run(async (ctx) => ctx.db.get(result.templateId));
		expect(template?.name.length).toBeLessThanOrEqual(100);
	});

	test("should handle unicode in templates", async () => {

		const { userId } = await t.mutation(api.users.ensure, {
			externalId: "user_sanitize_3",
		});

		const result = await t.mutation(api.promptTemplates.create, {
			userId,
			name: "æµ‹è¯•æ¨¡æ¿ ğŸš€",
			command: "/unicode",
			template: "Content with ä¸­æ–‡ and emojis ğŸ‰",
		});

		const template = await t.run(async (ctx) => ctx.db.get(result.templateId));
		expect(template?.name).toBe("æµ‹è¯•æ¨¡æ¿ ğŸš€");
		expect(template?.template).toBe("Content with ä¸­æ–‡ and emojis ğŸ‰");
	});
});
